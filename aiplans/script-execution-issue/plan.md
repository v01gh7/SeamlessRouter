# План: Исправление проблемы с выполнением скриптов при повторной навигации

## 1. Goal
Исправить проблему, когда скрипты не выполняются при повторном переходе на страницу. При переходе с одной страницы на другую и обратно код не выполняется, хотя он удаляется из DOM.

## 2. Context
Проект представляет собой клиентский роутер для SPA-приложений. Основные компоненты:
- `Router` - инициализация роутера
- `navigation.ts` - обработка навигации
- `updateHead.ts` - обновление head документа
- `updateBody.ts` - обновление body документа  
- `runScripts.ts` - выполнение скриптов
- `dom.ts` - утилиты для работы с DOM и скриптами
- `sandbox.ts` - система песочницы для скриптов

Проблема: при повторном переходе на страницу скрипты не выполняются, хотя они удаляются из DOM и добавляются заново.

## 3. Assumptions
1. Проблема связана с кэшированием скриптов в `scriptCache` (Set<string>)
2. Скрипты удаляются из DOM, но не удаляются из кэша
3. При повторном добавлении скрипта система проверяет кэш и пропускает выполнение
4. Проблема может быть в логике `appendFreshScript` или `removeExistingScript`
5. Система песочницы (`sandbox.ts`) может влиять на выполнение скриптов

## 4. Constraints
1. Нельзя ломать существующую функциональность
2. Должна сохраняться работа с атрибутами `data-keep`, `data-skip`, `data-reload`
3. Должна сохраняться система предотвращения дублирования скриптов
4. Решение должно быть совместимо с текущей архитектурой

## 5. Non-Goals
1. Переписывание всей системы роутинга
2. Изменение API или публичного интерфейса
3. Добавление новых функций, не связанных с проблемой
4. Оптимизация производительности (если не связана с проблемой)

## 6. Proposed Solution
Проанализировать и исправить логику кэширования скриптов:

### Основные проблемы:
1. **Кэш не очищается при удалении скриптов**: `scriptCache` содержит хэши скриптов, но при удалении скрипта из DOM хэш не удаляется из кэша
2. **Логика `removeExistingScript`**: удаляет скрипты из DOM, но не из кэша
3. **Логика `appendFreshScript`**: проверяет кэш перед добавлением, но не учитывает, что скрипт мог быть удален

### Решения:
1. Добавить очистку кэша при удалении скриптов
2. Изменить логику проверки кэша: учитывать, удален ли скрипт из DOM
3. Возможно, добавить принудительное выполнение скриптов при повторной навигации на ту же страницу

## 7. Step-by-Step Plan

### Шаг 1: Анализ текущей логики кэширования
- Изучить `dom.ts`: `scriptCache`, `getScriptHash`, `appendFreshScript`, `removeExistingScript`
- Изучить `runScripts.ts`: `purgeAllScripts()` из песочницы
- Изучить `sandbox.ts`: как работает очистка скриптов

### Шаг 2: Поиск корневой причины
- Проверить, вызывается ли `purgeAllScripts()` при каждой навигации
- Проверить, очищается ли `scriptCache` при удалении скриптов
- Проверить логику `shouldPreserve` и `shouldSkip`

### Шаг 3: Разработка исправлений
**Вариант A**: Очищать кэш при удалении скриптов
- Модифицировать `removeExistingScript` для удаления хэша из `scriptCache`
- Добавить метод для очистки кэша при полной очистке скриптов

**Вариант B**: Изменить логику проверки кэша
- В `appendFreshScript` проверять не только кэш, но и наличие скрипта в DOM
- Добавить проверку: если скрипта нет в DOM, выполнять его независимо от кэша

**Вариант C**: Комбинированный подход
- Очищать кэш при удалении скриптов
- Добавить проверку наличия в DOM как дополнительную страховку

### Шаг 4: Реализация исправлений
1. Модифицировать `dom.ts`:
   - Добавить метод `removeScriptFromCache(hash: string)`
   - Обновить `removeExistingScript` для удаления из кэша
   - Добавить метод `clearScriptCache()` для полной очистки
   
2. Обновить `runScripts.ts`:
   - Вызывать `clearScriptCache()` в начале `runScripts()` или после `purgeAllScripts()`

3. Протестировать с существующими тестовыми страницами

### Шаг 5: Тестирование
1. Проверить переходы между страницами:
   - Главная → О нас → Главная → О нас
   - Проверить выполнение скриптов `test/main.js` и `test/head.js`
   
2. Проверить работу с атрибутами:
   - `data-keep`: скрипт должен сохраняться
   - `data-skip`: скрипт должен пропускаться
   - `data-reload`: скрипт должен перезагружаться

3. Проверить работу песочницы

## 8. Risks & Trade-offs

### Риски:
1. **Нарушение работы существующей функциональности**: Изменение логики кэширования может привести к дублированию скриптов
2. **Производительность**: Частая очистка кэша может снизить производительность
3. **Память**: Неправильное управление кэшем может привести к утечкам памяти

### Компромиссы:
1. **Полная очистка кэша vs частичная**: Полная очистка проще, но может привести к повторному выполнению скриптов, которые должны кэшироваться
2. **Проверка DOM vs кэш**: Проверка DOM медленнее, но надежнее

### Меры предосторожности:
1. Сохранить текущую логику для скриптов с `data-keep`
2. Тестировать на всех сценариях использования
3. Добавить логирование для отладки

## 9. Validation Criteria

### Критерии успеха:
1. Скрипты выполняются при каждом переходе на страницу (если нет `data-keep`)
2. Скрипты с `data-keep` сохраняются между переходами
3. Скрипты с `data-skip` пропускаются
4. Скрипты с `data-reload` перезагружаются при каждом переходе
5. Нет дублирования скриптов в DOM
6. Консольные сообщения из тестовых скриптов появляются при каждом переходе

### Тестовые сценарии:
1. Переход Главная → О нас → Главная → О нас
2. Переход Главная → Контакты → Главная → Контакты  
3. Переход О нас → Контакты → О нас → Контакты
4. Проверка работы `window.kek` переменной

## 10. Rollback / Recovery Plan

### Откат изменений:
1. Сохранить копии изменяемых файлов перед модификацией
2. Использовать git для контроля версий
3. Возможность быстрого отката к предыдущей версии

### Восстановление:
1. Если изменения нарушают работу:
   - Откатить изменения в `dom.ts`
   - Откатить изменения в `runScripts.ts`
   - Проверить работоспособность исходной версии
   
2. Альтернативный подход:
   - Реализовать более консервативное исправление
   - Добавить флаг для управления поведением

## 11. Open Questions - Answered

### 11.1 Как работает `purgeAllScripts()` из песочницы?
**Ответ:** Изучил `sandbox.ts`. `purgeAllScripts()` делает:
1. Удаляет все скрипты из DOM (кроме с `data-keep`)
2. Вызывает `cleanupSandbox()` для каждого скрипта (очищает таймеры, интервалы, слушатели событий)
3. Очищает глобальные записи (таймеры, интервалы, слушатели)
4. **НО:** Не очищает `scriptCache` из `dom.ts`!

### 11.2 Есть ли другие места, где используется `scriptCache`?
**Ответ:** Проверил весь код. `scriptCache` используется только в `dom.ts`:
- Строка 9: `const scriptCache = new Set<string>();`
- Строка 38: Проверка `if (scriptCache.has(hash) && !forceReload) return;`
- Строка 54: Добавление `scriptCache.add(hash);`

### 11.3 Как обрабатываются inline скрипты vs external скрипты?
**Ответ:** Проверил логику в `dom.ts`:
- **External скрипты:** Хэш = `src:${src}`
- **Inline скрипты:** Хэш = `code:${hashCode(normalizedCode)}`
- Одинаковая логика кэширования для обоих типов
- `removeExistingScript` по-разному ищет скрипты в DOM:
  - External: `script[src="${src}"]`
  - Inline: `script:not([src])` с сравнением текста

### 11.4 Нужно ли учитывать порядок выполнения скриптов?
**Ответ:** Да, но текущая система не сохраняет порядок:
- Скрипты извлекаются из body в `extractScripts()` (сохраняет порядок)
- Но `appendFreshScript` добавляет их по одному без гарантии порядка
- Проблема может возникнуть, если скрипты зависят друг от друга
- **Для текущей проблемы:** Порядок не является корневой причиной, но стоит учитывать

### 11.5 Как тестировать изменения без dev сервера?
**Ответ:** Можно тестировать так:
1. **Статический анализ:** Проверка логики кода
2. **Unit-тесты в уме:** Анализ сценариев
3. **Сборка проекта:** `npm run build` для проверки ошибок компиляции
4. **Ручное тестирование после сборки:** Открыть HTML файлы в браузере
5. **Проверка консоли:** Логи выполнения скриптов

**Конкретный план тестирования:**
1. Собрать проект: `npm run build`
2. Открыть `index.html` в браузере
3. Проверить переходы по ссылкам
4. Проверить консоль на выполнение скриптов
5. Проверить переменные `window.kek`

### Выводы из анализа:
1. **Корневая причина:** `scriptCache` не очищается при удалении скриптов
2. `purgeAllScripts()` очищает DOM и песочницу, но не кэш
3. При повторном добавлении скрипта `appendFreshScript` видит его в кэше и пропускает
4. **Решение:** Очищать `scriptCache` при удалении скриптов или в `purgeAllScripts()`